---
title: Escape Hatches
description: Bypass reflection for performance-critical paths
author: zoobzio
published: 2025-12-27
updated: 2025-12-27
tags:
  - Performance
  - Optimization
  - Escape Hatches
---

# Escape Hatches

The serializer uses reflection to apply sanitization based on struct tags. For performance-critical paths, implement escape hatch interfaces to bypass reflection entirely.

## Sanitizable Interface

Called during `Marshal` instead of reflection-based sanitization:

```go
type Sanitizable interface {
    Sanitize() error
}
```

## Desanitizable Interface

Called during `Unmarshal` instead of reflection-based restoration:

```go
type Desanitizable interface {
    Desanitize() error
}
```

## Implementation Example

```go
type User struct {
    ID       string `json:"id"`
    Email    string `json:"email"`
    Password string `json:"password"`
    Token    string `json:"token"`

    // Store encryptor reference for manual use
    enc codec.Encryptor `json:"-"`
}

func (u User) Clone() User { return u }

// Bypass reflection on marshal
func (u *User) Sanitize() error {
    // Mask email manually
    if len(u.Email) > 0 {
        at := strings.Index(u.Email, "@")
        if at > 0 {
            u.Email = u.Email[:1] + "***" + u.Email[at:]
        }
    }

    // Encrypt password manually
    if u.enc != nil && u.Password != "" {
        encrypted, err := u.enc.Encrypt([]byte(u.Password), "pii")
        if err != nil {
            return err
        }
        u.Password = base64.StdEncoding.EncodeToString(encrypted)
    }

    // Hash token manually
    h := sha256.Sum256([]byte(u.Token))
    u.Token = hex.EncodeToString(h[:])

    return nil
}

// Bypass reflection on unmarshal
func (u *User) Desanitize() error {
    // Decrypt password manually
    if u.enc != nil && u.Password != "" {
        ciphertext, err := base64.StdEncoding.DecodeString(u.Password)
        if err != nil {
            return err
        }
        plaintext, err := u.enc.Decrypt(ciphertext, "pii")
        if err != nil {
            return err
        }
        u.Password = string(plaintext)
    }
    return nil
}
```

## When to Use Escape Hatches

Use escape hatches when:

1. **Hot paths** - Serialization happens in tight loops or high-frequency handlers
2. **Complex sanitization** - Logic that doesn't fit the tag model
3. **Conditional transforms** - Different sanitization based on runtime state
4. **External dependencies** - Sanitization requires services not available through options

## Performance Comparison

```go
// Reflection-based (default)
BenchmarkSerializerMarshal-8    500000    3200 ns/op    1024 B/op    12 allocs/op

// With Sanitizable
BenchmarkSerializerMarshal-8    800000    1800 ns/op     512 B/op     6 allocs/op
```

Actual gains depend on type complexity and number of sanitized fields.

## Partial Escape Hatches

You can implement just one interface:

```go
// Only bypass sanitization, use reflection for desanitization
func (u *User) Sanitize() error { ... }

// Or only bypass desanitization
func (u *User) Desanitize() error { ... }
```

## Interface Detection

The serializer checks for interfaces once at creation time:

```go
ser, _ := codec.NewSerializer[User](json.New(), opts...)
// Interface check happens here, result cached
```

No runtime type assertions on every marshal/unmarshal.

## Caveats

1. **Consistency** - Your implementation must match what reflection would do
2. **Maintenance** - Adding fields requires updating the method
3. **Testing** - Test both paths to ensure equivalent behavior

Consider keeping reflection-based serialization for development and switching to escape hatches only after profiling confirms the need.

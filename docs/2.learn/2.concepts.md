---
title: Concepts
description: Core concepts and design principles
author: zoobzio
published: 2025-12-27
updated: 2025-12-27
tags:
  - Concepts
  - Architecture
---

# Concepts

## Codec vs Processor

**Codec** is a simple interface for marshaling and unmarshaling:

```go
type Codec interface {
    ContentType() string
    Marshal(v any) ([]byte, error)
    Unmarshal(data []byte, v any) error
}
```

Use a codec directly when you need basic encoding without transforms.

**Processor[T]** wraps a codec with boundary-aware transforms:

```go
type Processor[T Cloner[T]] struct {
    // ...
}

func (p *Processor[T]) Receive(ctx context.Context, data []byte) (*T, error)
func (p *Processor[T]) Load(ctx context.Context, data []byte) (*T, error)
func (p *Processor[T]) Store(ctx context.Context, obj *T) ([]byte, error)
func (p *Processor[T]) Send(ctx context.Context, obj *T) ([]byte, error)
```

Use a processor when data needs different treatment at different boundaries.

## The Four Boundaries

Data flows through four boundaries:

```
External World              Your Application              Storage
     │                            │                          │
     │  ──── Receive ────>        │                          │
     │                            │  ──── Store ────>        │
     │                            │  <──── Load ─────        │
     │  <──── Send ──────         │                          │
     │                            │                          │
```

| Boundary | Operation | Transforms | Example |
|----------|-----------|------------|---------|
| Receive | `Receive()` | `receive.hash` | Hash passwords from API requests |
| Load | `Load()` | `load.decrypt` | Decrypt fields from database |
| Store | `Store()` | `store.encrypt` | Encrypt fields for database |
| Send | `Send()` | `send.mask`, `send.redact` | Mask PII in API responses |

## Cloner[T] Constraint

All types used with `Processor[T]` must implement `Cloner[T]`:

```go
type Cloner[T any] interface {
    Clone() T
}
```

This ensures the original value is never modified during transforms.

For value types with no pointers, slices, or maps:

```go
func (u User) Clone() User { return u }
```

For types with reference fields:

```go
func (u User) Clone() User {
    clone := u
    if u.Tags != nil {
        clone.Tags = make([]string, len(u.Tags))
        copy(clone.Tags, u.Tags)
    }
    return clone
}
```

## Boundary Tags

Struct tags declare which transforms apply at which boundaries:

```go
type User struct {
    // Hash on receive (incoming data)
    Password string `receive.hash:"sha256"`

    // Encrypt on store, decrypt on load
    Email string `store.encrypt:"aes" load.decrypt:"aes"`

    // Mask on send (outgoing data)
    SSN string `send.mask:"ssn"`

    // Redact on send
    Token string `send.redact:"[HIDDEN]"`
}
```

### Tag Format

```
boundary.operation:"algorithm"
```

| Boundary | Operations |
|----------|------------|
| `receive` | `hash` |
| `load` | `decrypt` |
| `store` | `encrypt` |
| `send` | `mask`, `redact` |

### Tag Values

Tag values reference registered algorithms:

```go
// Tag value "aes" maps to EncryptAES
Email string `store.encrypt:"aes"`

// Registration
proc.SetEncryptor(cereal.EncryptAES, enc)
```

Built-in algorithms:

| Type | Constants |
|------|-----------|
| Encryption | `EncryptAES`, `EncryptRSA`, `EncryptEnvelope` |
| Hashing | `HashSHA256`, `HashSHA512`, `HashArgon2`, `HashBcrypt` |
| Masking | `MaskEmail`, `MaskSSN`, `MaskPhone`, `MaskCard`, `MaskIP`, `MaskUUID`, `MaskIBAN`, `MaskName` |

## Configuration via Setters

Processors are configured with setter methods:

```go
proc, _ := cereal.NewProcessor[User](json.New())

// Configure encryption
enc, _ := cereal.AES(key)
proc.SetEncryptor(cereal.EncryptAES, enc)

// Configure custom hasher
proc.SetHasher(cereal.HashArgon2, customArgon2)

// Configure custom masker
proc.SetMasker(cereal.MaskEmail, customEmailMasker)
```

Setters return the processor for chaining:

```go
proc.SetEncryptor(cereal.EncryptAES, aesEnc).
    SetEncryptor(cereal.EncryptRSA, rsaEnc).
    SetHasher(cereal.HashArgon2, argon2)
```

## Validation

Validation runs automatically on the first operation. If a required handler is missing, the operation returns an error:

```go
proc, _ := cereal.NewProcessor[User](json.New())
// Forgot to configure encryptor...

data, err := proc.Store(ctx, &user)
// err: missing encryptor for algorithm "aes" (field Email)
```

For fail-fast behavior at startup, call `Validate()` explicitly:

```go
proc, _ := cereal.NewProcessor[User](json.New())
proc.SetEncryptor(cereal.EncryptAES, enc)

if err := proc.Validate(); err != nil {
    log.Fatal(err) // Catch configuration errors immediately
}
```

Validation checks that all algorithms referenced in tags have registered handlers. Types implementing override interfaces (`Encryptable`, `Decryptable`, `Hashable`, `Maskable`) bypass validation for their respective transform types.

## Sentinel Integration

The processor uses [sentinel](https://github.com/zoobzio/sentinel) for struct metadata. On creation, it scans the type once and caches field plans:

```go
// Type is scanned once
proc, _ := cereal.NewProcessor[User](json.New())

// Cached plans used for all operations
proc.Store(ctx, &user1)
proc.Store(ctx, &user2)
```

This avoids repeated reflection on every operation.

## Registry Caching

For frequently-used processors, the registry provides thread-safe caching via `Use`:

```go
// First call creates and caches
proc1, _ := cereal.Use[User](json.New())

// Subsequent calls return cached instance
proc2, _ := cereal.Use[User](json.New())

// proc1 == proc2 (same instance)
```

### When to Use the Registry

Use `Use[T]()` when:
- Multiple packages need the same processor
- You want singleton semantics for a type/codec combination
- Avoiding repeated reflection scanning matters

Use `NewProcessor[T]()` when:
- You need isolated configuration per instance
- Testing with different configurations
- Short-lived processors

### Cache Key

The registry keys by `(type, content-type)`. Same type with different codecs creates separate entries:

```go
jsonProc, _ := cereal.Use[User](json.New())   // Cached as (User, "application/json")
yamlProc, _ := cereal.Use[User](yaml.New())   // Cached as (User, "application/yaml")
```

### Configuration

Configure the cached processor after retrieval:

```go
proc, _ := cereal.Use[User](json.New())
proc.SetEncryptor(cereal.EncryptAES, enc) // Configures the cached instance
```

Since `Use` returns the same instance, configuration applies globally. Configure once at startup.

### Reset

Clear the registry with `Reset()`. Primarily useful for test isolation:

```go
func TestSomething(t *testing.T) {
    cereal.Reset() // Start with empty registry
    defer cereal.Reset() // Clean up after test

    proc, _ := cereal.Use[User](json.New())
    // ...
}
```

`Reset()` removes all cached processors. Subsequent `Use` calls create fresh instances.

## Override Interfaces

For performance-critical paths, implement these interfaces to bypass reflection:

```go
type Hashable interface {
    Hash(hashers map[HashAlgo]Hasher) error
}

type Encryptable interface {
    Encrypt(encryptors map[EncryptAlgo]Encryptor) error
}

type Decryptable interface {
    Decrypt(encryptors map[EncryptAlgo]Encryptor) error
}

type Maskable interface {
    Mask(maskers map[MaskType]Masker) error
}

type Redactable interface {
    Redact() error
}
```

When implemented, the processor calls these methods instead of using reflection.

See [Override Interfaces](../4.cookbook/1.escape-hatches.md) for implementation guidance.

## Context Propagation

All operations accept `context.Context`:

```go
proc.Receive(ctx, data)
proc.Load(ctx, data)
proc.Store(ctx, obj)
proc.Send(ctx, obj)
```

Context flows through to signal emission for tracing integration. Pass your request context to correlate operations with traces.

## Thread Safety

Processors are safe for concurrent use. Multiple goroutines can call `Receive`, `Load`, `Store`, and `Send` simultaneously on the same processor instance.

Configuration methods (`SetEncryptor`, `SetHasher`, `SetMasker`) use internal synchronization and can be called during operation, though typically configuration happens at startup.

```go
proc, _ := cereal.NewProcessor[User](json.New())
proc.SetEncryptor(cereal.EncryptAES, enc)

// Safe: concurrent operations on same processor
go func() { proc.Store(ctx, &user1) }()
go func() { proc.Store(ctx, &user2) }()
go func() { proc.Load(ctx, data) }()
```

## Nested Struct Support

Transforms apply to nested structs:

```go
type Address struct {
    Street string `json:"street"`
    City   string `json:"city" send.redact:"[HIDDEN]"`
}

type User struct {
    Name    string  `json:"name" send.mask:"name"`
    Address Address `json:"address"` // City will be redacted on Send
}
```

Both direct fields and nested struct fields are processed.

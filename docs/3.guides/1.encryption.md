---
title: Encryption
description: Encrypt and hash sensitive fields
author: zoobzio
published: 2025-12-27
updated: 2025-12-27
tags:
  - Encryption
  - Hashing
  - Security
---

# Encryption

Codec provides three built-in encryptors and two hashers.

## AES-GCM

Symmetric encryption using AES-256 in GCM mode:

```go
key := make([]byte, 32) // 256-bit key
rand.Read(key)

enc, err := codec.AES(key)
if err != nil {
    // Key must be 16, 24, or 32 bytes
}

ser, _ := codec.NewSerializer[User](
    json.New(),
    codec.WithEncryptor("pii", enc),
)
```

- Requires 16, 24, or 32 byte key (AES-128, AES-192, AES-256)
- Random nonce prepended to ciphertext
- Authenticated encryption prevents tampering

## RSA-OAEP

Asymmetric encryption for scenarios where encrypt and decrypt happen in different contexts:

```go
// Generate key pair
priv, _ := rsa.GenerateKey(rand.Reader, 2048)
pub := &priv.PublicKey

// Full encryptor (can encrypt and decrypt)
enc := codec.RSA(pub, priv)

// Encrypt-only encryptor (for client-side)
encryptOnly := codec.RSA(pub, nil)
```

- Uses SHA-256 for OAEP padding
- Public key encrypts, private key decrypts
- Pass `nil` for private key if decrypt not needed

## Envelope Encryption

For encrypting large fields or when you need key rotation:

```go
masterKey := make([]byte, 32) // 16, 24, or 32 bytes
rand.Read(masterKey)

enc, err := codec.Envelope(masterKey)
```

How it works:
1. Generate a random data encryption key (DEK) per operation
2. Encrypt the field with the DEK (AES-GCM)
3. Encrypt the DEK with the master key
4. Prepend encrypted DEK to ciphertext

Benefits:
- Master key never touches plaintext directly
- Key rotation: re-encrypt DEKs, data unchanged
- Large fields don't stress the master key

## Multiple Encryptors

Register different encryptors for different sensitivity levels:

```go
piiEnc, _ := codec.AES(piiKey)
secretEnc, _ := codec.Envelope(secretMasterKey)

ser, _ := codec.NewSerializer[Record](
    json.New(),
    codec.WithEncryptor("pii", piiEnc),
    codec.WithEncryptor("secret", secretEnc),
)

type Record struct {
    Email    string `encrypt:"pii"`    // Uses piiEnc
    APIKey   string `encrypt:"secret"` // Uses secretEnc
}
```

## Hashing

One-way hashing for fields that should never be recovered:

```go
ser, _ := codec.NewSerializer[User](
    json.New(),
    codec.WithHasher("sha256", codec.SHA256()),
    codec.WithHasher("sha512", codec.SHA512()),
)

type User struct {
    Token     string `hash:"sha256"`
    SecretKey string `hash:"sha512"`
}
```

Hashed values are hex-encoded in the output.

### When to Hash vs Encrypt

| Use Case | Approach |
|----------|----------|
| Need original value back | `encrypt` |
| Verification only (compare hashes) | `hash` |
| Audit trail | `hash` |
| Password storage | Neither (use bcrypt/argon2) |

## Custom Encryptors

Implement the `Encryptor` interface for custom schemes:

```go
type Encryptor interface {
    Encrypt(plaintext []byte, ctx string) ([]byte, error)
    Decrypt(ciphertext []byte, ctx string) ([]byte, error)
}
```

The `ctx` parameter is the tag value, allowing context-aware encryption:

```go
type myEncryptor struct{}

func (e *myEncryptor) Encrypt(plaintext []byte, ctx string) ([]byte, error) {
    // ctx is the tag value, e.g., "pii" from encrypt:"pii"
    return customEncrypt(plaintext, ctx)
}
```

## Custom Hashers

Implement the `Hasher` interface:

```go
type Hasher interface {
    Hash(data []byte) string
}
```

The return value is used directly in the output (typically hex-encoded).
